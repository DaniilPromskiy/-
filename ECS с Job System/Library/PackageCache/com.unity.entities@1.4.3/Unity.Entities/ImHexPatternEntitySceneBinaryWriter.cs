#if UNITY_DOTS_IMHEX
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.Entities
{
    public struct ImHexPatternEntitySceneBinaryWriter : IDisposable
    {
        public static World currentWorld { private get; set; }

        public bool shouldWriteToDisk { private get; set; }

        public string fileName { get; set; }

        IndentedTextWriter m_IndentedTextWriter;
        HashSet<Type> m_AlreadyWrittenTypes;
        HashSet<string> m_AlreadyWrittenTypeNames;
        HashSet<string> m_AlreadyWrittenOuterVariableNames;

        public static unsafe ImHexPatternEntitySceneBinaryWriter Create(string fileName, string headerAppend = "", EntityManager entityManager = default)
        {
            if (entityManager.GetUncheckedEntityDataAccess() == null)
                entityManager = currentWorld?.EntityManager ?? World.DefaultGameObjectInjectionWorld?.EntityManager ?? default;

            if (entityManager.GetUncheckedEntityDataAccess() != null)
                headerAppend += CreateStableTypeNameFunction(entityManager);

            var writer = new ImHexPatternEntitySceneBinaryWriter
            {
                shouldWriteToDisk = true,
                m_IndentedTextWriter = new IndentedTextWriter(new StringWriter()),
                m_AlreadyWrittenTypes = new HashSet<Type>(),
                m_AlreadyWrittenTypeNames = new HashSet<string>(),
                m_AlreadyWrittenOuterVariableNames = new HashSet<string>(),
                fileName = fileName
            };
            writer.WriteHeader(headerAppend, fileName);
            return writer;
        }

        static string CreateStableTypeNameFunction(EntityManager entityManager)
        {
            using var writer = new IndentedTextWriter(new StringWriter());
            using var allTypes = new NativeHashSet<ComponentType>(100, Allocator.Temp);
            using var archetypes = new NativeList<EntityArchetype>(Allocator.Temp);
            
            entityManager.GetAllArchetypes(archetypes);
            foreach (var archetype in archetypes)
            {
                unsafe
                {
                    if (archetype.Archetype->EntityCount == 0)
                        continue;
                }

                using var componentTypes = archetype.GetComponentTypes();
                foreach (var componentType in componentTypes)
                    allTypes.Add(componentType);
            }

            // StableTypeHash value mapper
            writer.WriteLine("/// StableTypeHash values are used to identify types in the binary format. This function maps the StableTypeHash to a human-readable name.");
            writer.WriteLine("fn get_stabletype_name(u64 stableTypeHash) {");
            writer.Indent++;
            writer.WriteLine("str name = \"\";");
            writer.WriteLine("match (stableTypeHash) {");
            writer.Indent++;

            foreach (var componentType in allTypes)
            {
                var typeInfo = TypeManager.GetTypeInfo(componentType.TypeIndex);
                writer.WriteLine($"\t({typeInfo.StableTypeHash}): name = \"{typeInfo.Type?.FullName ?? typeInfo.DebugTypeName.ToString()}\";");
            }

            writer.WriteLine("\t(_): name = \"Unknown Type\";");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
            writer.WriteLine(@"return std::format(""{} (sth:{})"", name, stableTypeHash);");
            writer.Indent--;
            writer.WriteLine("};");

            return writer.InnerWriter.ToString();
        }

        void WriteHeader(string headerAppend, string name)
        {
            m_IndentedTextWriter.WriteLine($"// This file is auto-generated by ImHexPatternEntitySceneBinaryWriter for '{name}'");
            m_IndentedTextWriter.WriteLine("// Do not edit this file manually.");
            m_IndentedTextWriter.WriteLine();

            m_IndentedTextWriter.WriteLine(headerAppend);
        }

        public void WriteArrayOfTypeWithPosition<T>(string name, long position, int elementCount, string comment = "") => WriteArrayOfTypeWithPosition(typeof(T), name, position, elementCount, comment);
        public void WriteArrayOfTypeWithPosition(Type type, string name, long position, int elementCount, string comment = "")
        {
            if (!type.IsPrimitive)
                WriteImHexType(type);
            var newName = name;
            var index = 0;
            while (!m_AlreadyWrittenOuterVariableNames.Add(newName))
            {
                newName = $"{name}_{++index}";
            }

            m_IndentedTextWriter.WriteLine($"{GetImHexPatternNameForType(type)} {newName}[{elementCount}] @ {position}{GetCommentText(comment)};");
        }

        void WriteImHexType(Type type)
        {
            var queue = new Queue<Type>();
            var typesToAdd = new Stack<Type>();
            queue.Enqueue(type);
            typesToAdd.Push(type);

            CollectTypesToWrite(queue, typesToAdd);
            WriteTypesToWriter(typesToAdd);
        }

        static void CollectTypesToWrite(Queue<Type> queue, Stack<Type> typesToAdd)
        {
            while (queue.Count > 0)
            {
                var currentType = queue.Dequeue();

                foreach (var fieldInfo in currentType.GetRuntimeFields())
                {
                    if (fieldInfo.IsStatic)
                        continue;

                    var fieldType = fieldInfo.FieldType;
                    // Add non-primitives that are also not fixed buffer types of primitives
                    if (!fieldType.IsPrimitive && fieldType != typeof(void*))
                    {
                        queue.Enqueue(fieldType);
                        typesToAdd.Push(fieldType);
                    }
                }

                if (currentType.IsGenericType)
                {
                    foreach (var genType in currentType.GenericTypeArguments)
                    {
                        if (genType.IsPrimitive || genType.IsPointer)
                            continue;

                        queue.Enqueue(genType);
                        typesToAdd.Push(genType);
                    }
                }
            }
        }

        void WriteTypesToWriter(Stack<Type> typesToAdd)
        {
            while (typesToAdd.Count > 0)
            {
                var currentType = typesToAdd.Pop();
                if (currentType.IsArray)
                    currentType = currentType.GetElementType();

                switch (currentType)
                {
                    case var _ when m_AlreadyWrittenTypes.Contains(currentType):
                    case var _ when m_AlreadyWrittenTypeNames.Contains(currentType.Name):
                        break;
                    case var _ when currentType.IsPrimitive:
                        Debug.LogError($"Should not be hit, primitive type {TypeHelper.GetHexTypeFullName(currentType)} found in queue.");
                        break;
                    case var _ when TypeHelper.IsUnityComponent(currentType):
                        WriteUnityComponent(m_IndentedTextWriter, currentType, sizeof(int));
                        m_AlreadyWrittenTypes.Add(currentType);
                        break;
                    case var _ when TypeHelper.IsUnityObjectRef(currentType):
                        WriteUnityComponent(m_IndentedTextWriter, currentType, sizeof(long));
                        m_AlreadyWrittenTypeNames.Add(currentType.Name);
                        break;
                    case var _ when currentType.IsEnum:
                        WriteEnum(m_IndentedTextWriter, currentType);
                        m_AlreadyWrittenTypes.Add(currentType);
                        break;
                    default:
                        string typeStr;
                        if (currentType.IsGenericType || TypeHelper.IsFakeGeneric(currentType))
                        {
                            typeStr = GetGenericTypeString(currentType, false);
                            m_AlreadyWrittenTypeNames.Add(currentType.Name);
                        }
                        else if (TypeHelper.IsChunkComponent(currentType))
                            typeStr = "ChunkComponent";
                        else
                            typeStr = TypeHelper.GetHexTypeFullName(currentType);

                        m_IndentedTextWriter.WriteLine($"struct {typeStr} {{");
                        m_IndentedTextWriter.Indent++;

                        var fieldSizeCounter = 0;
                        foreach (var fieldInfo in currentType.GetRuntimeFields())
                        {
                            WriteField(m_IndentedTextWriter, fieldInfo);
                            fieldSizeCounter += fieldInfo.FieldType.IsValueType ? UnsafeUtility.SizeOf(fieldInfo.FieldType) : GetSizeOfUnityClass(fieldInfo.FieldType);
                        }

                        m_IndentedTextWriter.Indent--;
                        var sizeOfType = currentType.IsValueType
                            ? UnsafeUtility.SizeOf(currentType)
                            : fieldSizeCounter;

                        m_IndentedTextWriter.WriteLine($"}} [[fixed_size({sizeOfType})]]{GetCommentText(GetPremadeComment(currentType))};\n");
                        m_AlreadyWrittenTypes.Add(currentType);
                        break;
                }
            }
        }

        static void WriteUnityComponent(IndentedTextWriter writer, Type type, int componentSize)
        {
            writer.WriteLine($"struct {TypeHelper.GetHexTypeFullName(type)} {{");
            writer.Indent++;
            writer.WriteLine($"{GetImHexPatternNameForPrimitiveType(typeof(int))} instanceId @ addressof(this)+0;");
            writer.Indent--;
            writer.WriteLine($"}} [[fixed_size({componentSize})]]{GetCommentText(GetPremadeComment(type))};\n");
        }

        static void WriteEnum(IndentedTextWriter writer, Type type)
        {
            writer.WriteLine($"enum {TypeHelper.GetHexTypeFullName(type)} : {GetImHexPatternNameForPrimitiveType(type.GetEnumUnderlyingType())} {{");
            writer.Indent++;
            var enumNames = type.GetEnumNames();
            for (var i = 0; i < enumNames.Length; ++i)
            {
                writer.WriteLine(i < enumNames.Length - 1 ? $"{enumNames[i]}," : $"{enumNames[i]}");
            }
            writer.Indent--;
            writer.WriteLine("};");
        }

        static void WriteField(IndentedTextWriter writer, FieldInfo fieldInfo)
        {
            if (fieldInfo.IsStatic)
                return;

            var fieldType = fieldInfo.FieldType;
            switch (fieldType)
            {
                case var _ when fieldType.IsPrimitive:
                    writer.Write($"{GetImHexPatternNameForPrimitiveType(fieldType)} {fieldInfo.Name}");
                    break;
                case var _ when TypeHelper.IsUnityObjectRef(fieldType):
                    writer.Write($"{TypeHelper.GetHexTypeFullName(fieldType)} {fieldInfo.Name}");
                    break;
                case var _ when fieldType.IsGenericType || TypeHelper.IsFakeGeneric(fieldType):
                    writer.Write($"{GetGenericTypeString(fieldType, true)} {fieldInfo.Name}");
                    break;
                case var _ when TypeHelper.IsChunkComponent(fieldType):
                    writer.Write($"ChunkComponent {fieldInfo.Name}");
                    break;
                case var _ when fieldType.IsPointer:
                    writer.Write($"{GetImHexPatternNameForPointerType(fieldType)} *{fieldInfo.Name} : {GetImHexPatternNameForPrimitiveType(typeof(int))}");
                    break;
                case var _ when fieldType.IsArray:
                    writer.Write($"{TypeHelper.GetHexTypeFullName(fieldType.GetElementType())} {fieldInfo.Name}[]");
                    break;
                default:
                    writer.Write($"{TypeHelper.GetHexTypeFullName(fieldType)} {fieldInfo.Name}");
                    break;
            }
            writer.WriteLine($" @ addressof(this)+{UnsafeUtility.GetFieldOffset(fieldInfo)}{GetCommentText(GetPremadeComment(fieldType, fieldInfo.Name))};");
        }

        static string GetPremadeComment(Type type, string fieldName = "") => type switch
        {
            { Name: "UInt64" } when fieldName is "StableTypeHash" => "StableTypeHash is a unique identifier for the type, used for serialization and deserialization.",
            _ => string.Empty
        };

        static string GetCommentText(string comment) => string.IsNullOrEmpty(comment) ? string.Empty : $" [[comment(\"{comment}\")]]";
        public void WriteTypeWithPosition<T>(string name, long position, string comment = "") => WriteTypeWithPosition(typeof(T), name, position, comment);
        public void WriteTypeWithPosition(Type type, string name, long position, string comment = "")
        {
            if (!type.IsPrimitive)
                WriteImHexType(type);
            var newName = name;
            var index = 0;
            while (!m_AlreadyWrittenOuterVariableNames.Add(newName))
            {
                newName = $"{name}_{++index}";
            }

            m_IndentedTextWriter.WriteLine($"{GetImHexPatternNameForType(type)} {newName} @ {position}{GetCommentText(comment)};");
        }

        static string GetImHexPatternNameForType(Type type)
        {
            if (type.IsPrimitive)
                return GetImHexPatternNameForPrimitiveType(type);
            if (type.IsGenericType)
                return GetGenericTypeString(type, true);

            return TypeHelper.GetHexTypeFullName(type);
        }

        static string GetGenericTypeString(Type type, bool shouldAddRealType)
        {
            var sb = new System.Text.StringBuilder();

            var fullName = type.FullName;
            var typeName = fullName.Split('`')[0].Replace('.', '_');

            if (type.IsGenericType)
            {
                sb.Append($"{typeName}<");
                var genericArguments = type.GetGenericArguments();
                for (var i = 0; i < genericArguments.Length; ++i)
                {
                    sb.Append(shouldAddRealType ? GetImHexPatternNameForType(genericArguments[i]) : $"T{i}");

                    if (i < genericArguments.Length - 1)
                        sb.Append(" ,");
                }

                sb.Append(">");
            }
            // E.g. Unity.Entities.BlobArray`1[[Unity.Entities.SceneSectionData, Unity.Entities, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]
            else
            {
                var allArgs = fullName.Split('[')[2].Split(',');
                var noOfArgs = int.Parse(fullName[fullName.IndexOf('`') + 1].ToString());

                sb.Append($"{typeName}<");
                for (var i = 0; i < noOfArgs; ++i)
                {
                    sb.Append(shouldAddRealType ? allArgs[i].Replace('.', '_') : $"T{i}");

                    if (i < noOfArgs - 1)
                        sb.Append(" ,");
                }
                sb.Append(">");
            }
            return sb.ToString();
        }

        static string GetImHexPatternNameForPrimitiveType(Type type) => type switch
        {
            { Name: "Byte" } => "u8",
            { Name: "SByte" } => "s8",
            { Name: "Int16" } => "s16",
            { Name: "UInt16" } => "u16",
            { Name: "Int32" } => "s32",
            { Name: "UInt32" } => "u32",
            { Name: "Int64" } => "s64",
            { Name: "UInt64" } => "u64",
            { Name: "Single" } => "float",
            { Name: "Double" } => "double",
            { Name: "Boolean" } => "bool",
            { Name: "Char" } => "char",
            _ => throw new NotSupportedException($"Type '{TypeHelper.GetHexTypeFullName(type)}' is not a supported primitive by ImHexPatternEntitySceneBinaryWriter.")
        };

        static string GetImHexPatternNameForPointerType(Type type) => type switch
        {
            { Name: "Void*" } => "u32",
            _ => TypeHelper.GetHexTypeFullName(type)
        };

        static int GetSizeOfUnityClass(Type type)
        {
            switch (type)
            {
                case var _ when type.Name == "CompanionReference":
                case var _ when type.IsGenericType && type.GetGenericTypeDefinition() == typeof(UnityObjectRef<>):
                    return sizeof(int);
                default:
                    return sizeof(int);
            }
        }

        public void Dispose()
        {
            if (m_IndentedTextWriter == null)
                return;
            if (!shouldWriteToDisk)
            {
                m_IndentedTextWriter.Dispose();
                return;
            }

            WriteFooter();
            if (!Directory.Exists("./Library/GeneratedImHex"))
                Directory.CreateDirectory("./Library/GeneratedImHex");

            var filePath = $"./Library/GeneratedImHex/{Path.GetFileName(fileName)}.hexpat";
            File.WriteAllText(filePath, m_IndentedTextWriter.InnerWriter.ToString());

            Debug.Log($"Created an .hexpat file from the recent bake, located at: {filePath} (Size: {new FileInfo(filePath).Length} bytes)");
            m_IndentedTextWriter.Dispose();
        }

        void WriteFooter()
        {
            m_IndentedTextWriter.WriteLine("// End of auto-generated file.");
            m_IndentedTextWriter.Flush();
        }
    }

    internal static class TypeHelper
    {
        public static string GetHexTypeFullName(Type type) => type.FullName
            .Replace('.', '_')
            .Replace('+', '_')
            .Replace('<', '_')
            .Replace('>', '_')
            .Replace("*", string.Empty)
            .Split(',')[0]
            .Split('`')[0];

        public static bool IsChunkComponent(Type type) => type.FullName != null && type.FullName.Contains("Unity.Entities.Chunk+<Buffer>");
        public static bool IsUnityComponent(Type type) => type.IsClass &&
                                                               (type.IsSubclassOf(typeof(UnityEngine.Component)) ||
                                                                type.IsSubclassOf(typeof(UnityEngine.MonoBehaviour)) ||
                                                                type == typeof(UnityEngine.Transform) ||
                                                                type == typeof(UnityEngine.GameObject));
        public static bool IsFakeGeneric(Type type) => type is {FullName: not null} && type.FullName.Contains("`");
        public static bool IsUnityObjectRef(Type type) => type.Name.Contains("UnityObjectRef");
    }
}

#endif
